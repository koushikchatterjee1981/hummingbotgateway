"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSwapOutput = exports.getSwapInput = exports.getShare = exports.getLp = exports.getFirstLp = exports.getAssetsRatio = exports.calculateLiquidity = exports.addLiquidity = void 0;
exports.getSwapRatio = getSwapRatio;
exports.getTokensForLp = void 0;
var _asset = require("@sundaeswap/asset");
var _fraction = require("@sundaeswap/fraction");
var _bigintMath = require("@sundaeswap/bigint-math");
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
/**
 * Get the lp token amount for a, b
 * @param a tokenA amount
 * @param b tokenB amount
 * @returns the minted lp token amount
 */
var getFirstLp = exports.getFirstLp = function getFirstLp(a, b) {
  return (0, _bigintMath.sqrt)(a * b);
};

/**
 * @deprecated
 */
var getLp = exports.getLp = getFirstLp;

/**
 * Get the share ratio as Fraction
 * @param lp
 * @param totalLp
 * @returns
 */
var getShare = exports.getShare = function getShare(lp, totalLp) {
  return new _fraction.Fraction(lp, totalLp);
};

/**
 * Calculate the Add (Mixed-Deposit) Liquidity parameters
 *
 * @param {bigint} a - The amount of token A to deposit.
 * @param {bigint} b - The amount of token B to deposit.
 * @param {bigint} aReserve - The current reserve of token A in the pool.
 * @param {bigint} bReserve - The current reserve of token B in the pool.
 * @param {bigint} totalLp - The total lp tokens for the pool before the deposit.
 * @throws {Error} If the pool doesn't have enough liquidity.
 * @throws {Error} If either of the deposit amounts is zero.
 * @returns {Object} An object containing:
 *   - nextTotalLp: The total lp tokens for the pool after the deposit.
 *   - generatedLp: The amount of lp tokens generated by the deposit.
 *   - shareAfterDeposit: The depositor's share of the pool after the deposit.
 */
var calculateLiquidity = exports.calculateLiquidity = function calculateLiquidity(a, b, aReserve, bReserve, totalLp) {
  if (aReserve === 0n || bReserve === 0n) {
    throw new Error("Not enough pool liquidity");
  }
  if (a === 0n || b === 0n) {
    throw new Error("Cannot use a deposit asset amount of 0");
  }
  var bInUnitsOfA = b * aReserve / bReserve;
  var aChange;
  var bChange;
  if (bInUnitsOfA > a) {
    bChange = bReserve * (bInUnitsOfA - a) / aReserve;
    aChange = 0n;
  } else {
    aChange = a - bInUnitsOfA;
    bChange = 0n;
  }

  // Subtract off the surplus as returned to the user
  var actualDepositedA = a - aChange;
  var actualDepositedB = b - bChange;

  // Calculate LP Tokens
  var newLpTokens = actualDepositedA * totalLp / aReserve;
  var newTotalLpTokens = totalLp + newLpTokens;
  return {
    nextTotalLp: newTotalLpTokens,
    generatedLp: newLpTokens,
    shareAfterDeposit: getShare(newLpTokens, newTotalLpTokens),
    bChange: bChange,
    aChange: aChange,
    actualDepositedA: actualDepositedA,
    actualDepositedB: actualDepositedB
  };
};

/**
 * @deprecated
 *
 * Use {@link calculateLiquidity} instead.
 */
var addLiquidity = exports.addLiquidity = function addLiquidity(a, aReserve, bReserve, totalLp) {
  var nextTotalLp = new _fraction.Fraction(totalLp * (a + aReserve), aReserve).quotient;
  var lp = nextTotalLp - totalLp;
  var b = new _fraction.Fraction(bReserve * a, aReserve);
  var share = getShare(lp, nextTotalLp);
  if (b.quotient === 0n) {
    throw new Error("The provided a asset is not enough to equal at least 1 of the b asset.");
  }
  return {
    nextTotalLp: nextTotalLp,
    /** @deprecated */
    lp: lp,
    generatedLp: lp,
    /** @deprecated */
    b: b.quotient,
    requiredB: b.quotient,
    /** @deprecated */
    share: share,
    shareAfterDeposit: share
  };
};

/**
 * Get the token amounts the given lp represents
 * @param lp the lp amount
 * @param aReserve the pool's reserveA amount
 * @param bReserve the pool's reserveB amount
 * @param totalLp the pool's total minted lp currently
 * @returns [a, b] token amounts
 */
var getTokensForLp = exports.getTokensForLp = function getTokensForLp(lp, aReserve, bReserve, totalLp) {
  return [new _fraction.Fraction(lp * aReserve, totalLp).quotient, new _fraction.Fraction(lp * bReserve, totalLp).quotient];
};
/**
 * Calculate swap outcome for a given input and pool parameters (input tokens, output tokens, fee).
 * Throws if
 *  - any of the arguments are negative
 *  - fee is greater than or equal 1
 *
 * @param input The given amount of tokens to be swapped
 * @param inputReserve The amount of tokens in the input reserve
 * @param outputReserve The amount of tokens in the output reserve
 * @param fractionFee The liquidity provider fee
 * @returns The swap details
 */
var getSwapOutput = exports.getSwapOutput = function getSwapOutput(input, inputReserve, outputReserve, fee, roundOutputUp) {
  if (input <= 0 || inputReserve <= 0 || outputReserve <= 0) throw new Error("Input and reserves must be positive");
  fee = _fraction.Fraction.asFraction(fee);
  if (fee.lt(_fraction.Fraction.ZERO) || fee.gt(_fraction.Fraction.ONE)) throw new Error("fee must be between 0 and 1");
  var feeDiff = fee.denominator - fee.numerator;
  var outputNumerator = outputReserve * input * feeDiff;
  var outputDenominator = inputReserve * fee.denominator + input * feeDiff;
  var output = new _fraction.Fraction(outputNumerator, outputDenominator);
  var safeOutput = roundOutputUp ? (outputNumerator + outputDenominator - 1n) / outputDenominator : output.quotient;
  var inputLpFee = new _fraction.Fraction(input * fee.numerator, fee.denominator).quotient;
  var nextInputReserve = inputReserve + input;
  var nextOutputReserve = outputReserve - safeOutput;

  // PRICEIMPACT: "priceImpact" is slightly misleadingly named in the industry as a whole
  // just by it's name, it would imply that it's the percentage difference between
  // the current price and the price after the swap, but it's actually the percentage
  // difference between the real price of your swap, and the price implied by the current
  // reserves; We got this wrong in v1, but this aligns it with the industry standard
  // Source: https://dailydefi.org/articles/price-impact-and-how-to-calculate/
  var amountInLessFee = input - inputLpFee;
  var idealPrice = new _fraction.Fraction(inputReserve, outputReserve);
  var actualPrice = new _fraction.Fraction(amountInLessFee, safeOutput);
  var priceImpact = _fraction.Fraction.ONE.subtract(idealPrice.divide(actualPrice));
  return {
    input: input,
    output: safeOutput,
    inputLpFee: inputLpFee,
    nextInputReserve: nextInputReserve,
    nextOutputReserve: nextOutputReserve,
    priceImpact: priceImpact
  };
};

/**
 * Calculate input required for a swap outcome for a given output and pool parameters (input tokens, output tokens, fee).
 * Throws if
 *  - any of the arguments are negative
 *  - fee is greater than or equal 1
 *  - output is greater than or equal to output reserve
 *
 * @param output
 * @param inputReserve
 * @param outputReserve
 * @param fee
 * @returns The swap details
 */
var getSwapInput = exports.getSwapInput = function getSwapInput(output, inputReserve, outputReserve, fee) {
  if (output <= 0 || inputReserve <= 0 || outputReserve <= 0) throw new Error("Output and reserves must be positive");
  if (output >= outputReserve) throw new Error("Output must be less than output reserve");
  fee = _fraction.Fraction.asFraction(fee);
  if (fee.lt(_fraction.Fraction.ZERO) || fee.gte(_fraction.Fraction.ONE)) throw new Error("fee must be [0,1)");
  var feeDiff = BigInt(fee.denominator - fee.numerator);
  var input = new _fraction.Fraction(inputReserve * output * fee.denominator, (outputReserve - output) * feeDiff).quotient + 1n;
  var inputLpFee = new _fraction.Fraction(input * fee.numerator, fee.denominator).quotient;
  var nextInputReserve = inputReserve + input;
  var nextOutputReserve = outputReserve - output;

  // See PRICEIMPACT
  var amountInLessFee = input - inputLpFee;
  var idealPrice = new _fraction.Fraction(inputReserve, outputReserve);
  var actualPrice = new _fraction.Fraction(amountInLessFee, output);
  var priceImpact = _fraction.Fraction.ONE.subtract(idealPrice.divide(actualPrice));
  return {
    input: input,
    output: output,
    inputLpFee: inputLpFee,
    nextInputReserve: nextInputReserve,
    nextOutputReserve: nextOutputReserve,
    priceImpact: priceImpact
  };
};

/**
 * Calculates the ratio between two values.
 *
 * @function
 * @param {TFractionLike} firstValue - The first value for the ratio calculation.
 * @param {TFractionLike} secondValue - The second value for the ratio calculation.
 * @returns {string|null} The ratio of the first value to the second value, expressed as a string in base 10. If either of the inputs is zero or negative, or if either input is missing, the function returns null.
 * @throws {Error} Will throw an error if the inputs are not valid for the Fraction class's `asFraction` method.
 */
var getAssetsRatio = exports.getAssetsRatio = function getAssetsRatio(firstValue, secondValue) {
  var first = _fraction.Fraction.asFraction(firstValue !== null && firstValue !== void 0 ? firstValue : 0);
  var second = _fraction.Fraction.asFraction(secondValue !== null && secondValue !== void 0 ? secondValue : 0);
  if (!first.greaterThan(0) || !second.greaterThan(0)) {
    return "0";
  }
  return first.divide(second).toString(10);
};

/**
 * Calculates the swap ratio between two assets and returns an AssetAmount instance representing this ratio.
 *
 * The assets are first sorted lexicographically by their assetId to ensure any calculation will match
 * pool ratios (which are also sorted lexicographically when created). The direction of the swap determines the calculation.
 * For 'A_PER_B', it calculates how much of the lexicographically first asset (A) is obtained for each unit of the
 * lexicographically second asset (B). For 'B_PER_A', it calculates how much of the lexicographically second asset (B)
 * is obtained for each unit of the lexicographically first asset (A).
 *
 * The returned AssetAmount is represented in the decimal format of the asset that is being received in the swap operation.
 * In 'A_PER_B' direction, the lexicographically first asset (A) is received, so the AssetAmount will be in the decimal format
 * of Asset A. In 'B_PER_A' direction, the lexicographically second asset (B) is received, so the AssetAmount will be in the decimal format of Asset B.
 *
 * @function
 * @param {TRatioDirection} direction - The direction of the swap: 'A_PER_B' means the first asset lexicographically is received and the second is given, 'B_PER_A' means the second asset lexicographically is received and the first is given.
 * @param {[IRatioCalculationAsset, IRatioCalculationAsset]} assets - An array of two assets involved in the swap. The order of the assets in this array does not matter as they will be sorted lexicographically by their assetId inside the function.
 *
 * @returns {TSwapRatio} The calculated swap ratio in different representations.
 *
 * @example
 *
 * ```ts
 * const asset1 = { quantity: 100, decimals: 0, assetId: 'B' };
 * const asset2 = { quantity: 2000000, decimals: 6, assetId: 'A' };
 * const amount = getSwapRatio('A_PER_B', [asset1, asset2]);
 * const sameAmount = getSwapRatio('A_PER_B', [asset2, asset1]);
 * console.log(amount.ratioAsFraction); // Returns a Fraction class of the ratio.
 * console.log(sameAmount.ratioAsFraction); // Same as above.
 * ```
 */
function getSwapRatio(direction, assets) {
  var calculatedAmount;
  var rawRatio;
  var adaIds = ["", ".", "ada.lovelace"];
  var _assets$sort = assets.sort(function (a, b) {
      var isASpecial = adaIds.includes(a.assetId);
      var isBSpecial = adaIds.includes(b.assetId);
      if (isASpecial && !isBSpecial) {
        return -1;
      }
      if (!isASpecial && isBSpecial) {
        return 1;
      }
      return a.assetId.localeCompare(b.assetId);
    }),
    _assets$sort2 = _slicedToArray(_assets$sort, 2),
    firstAsset = _assets$sort2[0],
    secondAsset = _assets$sort2[1];
  if (direction === "A_PER_B") {
    rawRatio = getAssetsRatio(firstAsset.quantity, secondAsset.quantity);
    calculatedAmount = _asset.AssetAmount.fromValue(Number(rawRatio) * Math.pow(10, secondAsset.decimals - firstAsset.decimals), firstAsset.decimals);
  } else {
    rawRatio = getAssetsRatio(secondAsset.quantity, firstAsset.quantity);
    calculatedAmount = _asset.AssetAmount.fromValue(Number(rawRatio) * Math.pow(10, firstAsset.decimals - secondAsset.decimals), secondAsset.decimals);
  }
  return {
    calculatedAmount: calculatedAmount,
    display: calculatedAmount.value.toString(),
    ratioAsFraction: _fraction.Fraction.asFraction(rawRatio),
    isDivisible: calculatedAmount.decimals > 0,
    belowMinimumRatio: rawRatio.toString() === "0"
  };
}
//# sourceMappingURL=ConstantProductPool.js.map