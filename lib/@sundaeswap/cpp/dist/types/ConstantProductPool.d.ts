import { AssetAmount } from "@sundaeswap/asset";
import { Fraction, TFractionLike } from "@sundaeswap/fraction";
export type TRatioDirection = "A_PER_B" | "B_PER_A";
export interface IRatioCalculationAsset {
    assetId: string;
    quantity: bigint;
    decimals: number;
}
export interface IRatioCalculationResult {
    calculatedAmount: AssetAmount;
    ratioAsFraction: Fraction;
    display: string;
    isDivisible: boolean;
    belowMinimumRatio: boolean;
}
export type TPair = [bigint, bigint];
/**
 * Get the lp token amount for a, b
 * @param a tokenA amount
 * @param b tokenB amount
 * @returns the minted lp token amount
 */
export declare const getFirstLp: (a: bigint, b: bigint) => bigint;
/**
 * @deprecated
 */
export declare const getLp: (a: bigint, b: bigint) => bigint;
/**
 * Get the share ratio as Fraction
 * @param lp
 * @param totalLp
 * @returns
 */
export declare const getShare: (lp: bigint, totalLp: bigint) => Fraction;
/**
 * Calculate the Add (Mixed-Deposit) Liquidity parameters
 *
 * @param {bigint} a - The amount of token A to deposit.
 * @param {bigint} b - The amount of token B to deposit.
 * @param {bigint} aReserve - The current reserve of token A in the pool.
 * @param {bigint} bReserve - The current reserve of token B in the pool.
 * @param {bigint} totalLp - The total lp tokens for the pool before the deposit.
 * @throws {Error} If the pool doesn't have enough liquidity.
 * @throws {Error} If either of the deposit amounts is zero.
 * @returns {Object} An object containing:
 *   - nextTotalLp: The total lp tokens for the pool after the deposit.
 *   - generatedLp: The amount of lp tokens generated by the deposit.
 *   - shareAfterDeposit: The depositor's share of the pool after the deposit.
 */
export declare const calculateLiquidity: (a: bigint, b: bigint, aReserve: bigint, bReserve: bigint, totalLp: bigint) => {
    nextTotalLp: bigint;
    generatedLp: bigint;
    shareAfterDeposit: Fraction;
    bChange: bigint;
    aChange: bigint;
    actualDepositedA: bigint;
    actualDepositedB: bigint;
};
/**
 * @deprecated
 *
 * Use {@link calculateLiquidity} instead.
 */
export declare const addLiquidity: (a: bigint, aReserve: bigint, bReserve: bigint, totalLp: bigint) => {
    nextTotalLp: bigint;
    /** @deprecated */
    lp: bigint;
    generatedLp: bigint;
    /** @deprecated */
    b: bigint;
    requiredB: bigint;
    /** @deprecated */
    share: Fraction;
    shareAfterDeposit: Fraction;
};
/**
 * Get the token amounts the given lp represents
 * @param lp the lp amount
 * @param aReserve the pool's reserveA amount
 * @param bReserve the pool's reserveB amount
 * @param totalLp the pool's total minted lp currently
 * @returns [a, b] token amounts
 */
export declare const getTokensForLp: (lp: bigint, aReserve: bigint, bReserve: bigint, totalLp: bigint) => TPair;
export type TSwapOutcome = {
    input: bigint;
    output: bigint;
    inputLpFee: bigint;
    nextInputReserve: bigint;
    nextOutputReserve: bigint;
    priceImpact: Fraction;
};
/**
 * Calculate swap outcome for a given input and pool parameters (input tokens, output tokens, fee).
 * Throws if
 *  - any of the arguments are negative
 *  - fee is greater than or equal 1
 *
 * @param input The given amount of tokens to be swapped
 * @param inputReserve The amount of tokens in the input reserve
 * @param outputReserve The amount of tokens in the output reserve
 * @param fractionFee The liquidity provider fee
 * @returns The swap details
 */
export declare const getSwapOutput: (input: bigint, inputReserve: bigint, outputReserve: bigint, fee: TFractionLike, roundOutputUp?: boolean) => TSwapOutcome;
/**
 * Calculate input required for a swap outcome for a given output and pool parameters (input tokens, output tokens, fee).
 * Throws if
 *  - any of the arguments are negative
 *  - fee is greater than or equal 1
 *  - output is greater than or equal to output reserve
 *
 * @param output
 * @param inputReserve
 * @param outputReserve
 * @param fee
 * @returns The swap details
 */
export declare const getSwapInput: (output: bigint, inputReserve: bigint, outputReserve: bigint, fee: TFractionLike) => TSwapOutcome;
/**
 * Calculates the ratio between two values.
 *
 * @function
 * @param {TFractionLike} firstValue - The first value for the ratio calculation.
 * @param {TFractionLike} secondValue - The second value for the ratio calculation.
 * @returns {string|null} The ratio of the first value to the second value, expressed as a string in base 10. If either of the inputs is zero or negative, or if either input is missing, the function returns null.
 * @throws {Error} Will throw an error if the inputs are not valid for the Fraction class's `asFraction` method.
 */
export declare const getAssetsRatio: (firstValue: TFractionLike, secondValue: TFractionLike) => string;
/**
 * Calculates the swap ratio between two assets and returns an AssetAmount instance representing this ratio.
 *
 * The assets are first sorted lexicographically by their assetId to ensure any calculation will match
 * pool ratios (which are also sorted lexicographically when created). The direction of the swap determines the calculation.
 * For 'A_PER_B', it calculates how much of the lexicographically first asset (A) is obtained for each unit of the
 * lexicographically second asset (B). For 'B_PER_A', it calculates how much of the lexicographically second asset (B)
 * is obtained for each unit of the lexicographically first asset (A).
 *
 * The returned AssetAmount is represented in the decimal format of the asset that is being received in the swap operation.
 * In 'A_PER_B' direction, the lexicographically first asset (A) is received, so the AssetAmount will be in the decimal format
 * of Asset A. In 'B_PER_A' direction, the lexicographically second asset (B) is received, so the AssetAmount will be in the decimal format of Asset B.
 *
 * @function
 * @param {TRatioDirection} direction - The direction of the swap: 'A_PER_B' means the first asset lexicographically is received and the second is given, 'B_PER_A' means the second asset lexicographically is received and the first is given.
 * @param {[IRatioCalculationAsset, IRatioCalculationAsset]} assets - An array of two assets involved in the swap. The order of the assets in this array does not matter as they will be sorted lexicographically by their assetId inside the function.
 *
 * @returns {TSwapRatio} The calculated swap ratio in different representations.
 *
 * @example
 *
 * ```ts
 * const asset1 = { quantity: 100, decimals: 0, assetId: 'B' };
 * const asset2 = { quantity: 2000000, decimals: 6, assetId: 'A' };
 * const amount = getSwapRatio('A_PER_B', [asset1, asset2]);
 * const sameAmount = getSwapRatio('A_PER_B', [asset2, asset1]);
 * console.log(amount.ratioAsFraction); // Returns a Fraction class of the ratio.
 * console.log(sameAmount.ratioAsFraction); // Same as above.
 * ```
 */
export declare function getSwapRatio(direction: TRatioDirection, assets: [IRatioCalculationAsset, IRatioCalculationAsset]): IRatioCalculationResult;
//# sourceMappingURL=ConstantProductPool.d.ts.map